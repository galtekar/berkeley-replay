# Assumptions:
# ``dbreak'' sets the specified breakpoint on all nodes
# ``dwatch'' sets the specified watchpoint on all nodes
# ``watch'' sets the specified watchpoint only on the active node
# ``dbreak'' and ``dwatch'' may be nested
# Auxiliarly Python functions may be defined

#debug
#debug

#py DEBUG=True
#py DEBUG=False

py sys.path.append("/home/galtekar/src/work/logreplay/console/examples")
py from disjoint import *

replay ./good10.txt











all

#set debug_level=2

# Mapping from nodes to neighbors.
py graph = zero_matrix(10,10)

# Mapping from Friday node IDs to app-level node IDs.
py nodes = {}

# Mapping from watchpoint number to neighbor pointer
py watchpoint_aux = {}


# We want to create a mapping from Friday node ID to IP address.
# This is how we do it with watchpoints. Note that the top-level
# breakpoint is unavoidable since we can't watch the IP address
# field until after the Server object has been created.
break config.cpp:73
command
# Create a mapping from Friday node ID to IP address.
my_addr = @(id)
print "my id: " + str(my_addr)
if my_addr != None:
	nodes[my_addr] = __NODE__
	raise ShouldContinueException
else:
	print "Host's ID is null."
end

py watch_set = set()

# Global Path Reliability Matrix. Entry (i,j) is the vclock
# time at which path i-->j was discovered by Friday to
# be reliable.
py global_PRM = zero_matrix(10, 10)

# Local Path Reliability Matrix. Entry (i,j) is the vclock
# time at which path i->j was discovered by node i to
# be reliable.
py local_PRM = zero_matrix(10, 10)

# Break at Server::init_neighbors, just right after creating each
# neighbor object. Use the opportunity to set watchpoints on
# key neighbor object state.
break server.cpp:355
command

neighbor_pointer = "(*(i->_M_node))"
neighbor_status_addr = @((long)&(%(neighbor_pointer)s->status))
neighbor_pointer_val = @(%(neighbor_pointer)s)

# It's possible that this breakpoint may fire more than
# once at the same location (usually twice) due to a bug.
# So this is a hack to ensure that there is at most 1
# watchpoint per address location per node.
if (__NODE__.index, neighbor_status_addr) in watch_set:
	raise ShouldContinueException

watch_set.add((__NODE__.index, neighbor_status_addr))

# Hack. The watch() places a watchpoint at the nodes
# in the main._current_replay_ids set.
save_ids = main._current_replay_ids
main._current_replay_ids = [__NODE__.index]

widx = watch( ["*%d"%neighbor_status_addr] )

# Associate the neighbor's pointer value with this watchpoint
# so that it is available for derefence in the watchpoint
# handler.
watchpoint_aux[widx] = neighbor_pointer_val
np = neighbor_pointer_val
#print "Saving pointer value to 0x%.2x%.2x%.2x%.2x"%(np[3], np[2], np[1], np[0])
#print "Pointer val ", neighbor_pointer_val

print "Setting watchpoint %d at 0x%x."%(widx, neighbor_status_addr)

set_command("""
main.call_gdb(__NODE__, "set language c", action="discard", may_hit_breakpoint=False)

# Update the graph when neighbor connects or disconnects.
nptr = watchpoint_aux[current_wp.index]
string_nptr = "0x%.2x%.2x%.2x%.2x"%(nptr[3], nptr[2], nptr[1], nptr[0])

#print "Stopped on watchpoint ", current_wp.index, " with ptr ", string_nptr

status = @((long)(((Neighbor*)(%(string_nptr)s))->status))
id = @((long)(((Neighbor*)(%(string_nptr)s))->id))
my_id = @((long)server->id)

print "My id is ", my_id, ", neighbor id is ", id, " with status ", status

# Update the graph if the status has changed to CONNECTED=1.
if status > 0:
	graph[my_id][id] = 1

print graph

# Compute number of disjoint paths to al nodes from current node.
# If the number meets the minimum (k), then mark the current vclock
# time.
k = @(server->k)
disjoint_paths = []
for node in range(len(graph)):
	real_k = len(vertex_disjoint_paths(graph, my_id, node))
	
	disjoint_paths.append(real_k)

	if real_k >= k:
		global_PRM[my_id][node] = __VCLOCK__
		#print global_PRM

print "Number of disjoint paths from ", my_id, " :", disjoint_paths

raise ShouldContinueException
"""+"end")

# Hack to make things work. Should be taken out for paper.
main._current_replay_ids = save_ids
raise ShouldContinueException
end

# DataContained::compute_flows. Upgrading node to be reliable.
# Mark the time in the local Path Reliability Matrix.
break dc.cpp:175
command

k = @(server->k)
source = @(server->id)
sink = @(sink) - 1


app_num_disjoint_paths = @((long)flow)
real_k = len(vertex_disjoint_paths(graph, source, sink))
local_PRM[source][sink] = __VCLOCK__
delay = local_PRM[source][sink] - global_PRM[source][sink]

if source == sink:
	print "Warning: node %d computing disjoint paths to self."%(source)

print "Node %d found %d disjoint paths from %d --> %d in %d seconds."%(source, app_num_disjoint_paths, source, sink, delay/1000000)

if real_k < k:
	print "Warning: %d --> %d has %d < %d disjoint paths, but %d sees %d."%(source, sink, real_k, k, sink, app_num_disjoint_paths)

# Does this node think that all sinks reliable? 
# It should eventually...
everyone_is_reliable = True
delay_sum = 0
max_delay = 0

for asink in range(len(local_PRM[source])):
	if asink != source:
		if local_PRM[source][asink] <= 0:
			everyone_is_reliable = False
		else:
			delay = local_PRM[source][asink] - global_PRM[source][asink]
			assert(delay > 0)
			delay_sum += delay
			if delay > max_delay:
				max_delay = delay

average_delay = delay_sum / len(local_PRM[source])
		
if everyone_is_reliable:
	print "Node %d has upgraded all nodes in %d seconds (%d seconds average)."%(source, max_delay, average_delay)

raise ShouldContinueException
end

# MessageHandler::process_dns_message.
# Got a message from an unreliable node. Verify that it is unreliable.
# If not, output a warning.
break message.cpp:858
command

source = @(message->id)
sink = @(server->id)
k = @(server->k)

print "Node %d got message from unreliable node %d."%(source, sink)

real_k = len(vertex_disjoint_paths(graph, source, sink))

if real_k >= k:
	# The source is reliable, but the sink doesn't think so.
	print "Warning: %d --> %d has %d >= %d disjoint paths, yet %d thinks it's unreliable."%(source, sink, 
		real_k, k, sink)

raise ShouldContinueException
end

# MessageHandler::process_dns_message
# Got a message from a reliable node. Verify that it is reliable.
# If not, output a warning.
break message.cpp:870
command

source = @(message->id)
sink = @(server->id)
k = @(server->k)

print "Node %d got message from reliable node %d."%(source, sink)

real_k = len(vertex_disjoint_paths(graph, source, sink))

if real_k < k:
	print "Warning: %d --> %d has %d < %d disjoint paths, yet %d thinks it's reliable."%(source, sink, 
		real_k, k, sink)

raise ShouldContinueException
end


###########################################################
# Each node should receive exactly #neighbor copies of 
# a DNS broadcast within M seconds. Getting more than
# #neighbor copies of a message might indicate a looping
# message or a message sent multiple times, neither of 
# which should happen. Not getting #neighbor copies within
# M seconds might inidicate a failure in one of the broadcast
# propagation paths.
#
# The advantage here is that you don't have to store a
# copy of all received messages to detect loops.
# Rather, this predicate knows exactly what message 
# (and number of copies) to expect--anything in excess
# indicates a problem.
###########################################################
py expected_messages = {}

# Node is sending out a DNS message. Add message to the
# expected bins of all other nodes.
break server.cpp:21
command

payload = @((unsigned char*)zero_buf)
my_id = @(server->id)

print "Adding payload ``%s'' to all bins."%(payload)

# Add message to all other bins, since we are
# broadcasting.
for node in range(len(graph)):
	if node not in expected_messages:
		print "creating set for node ", node
		expected_messages[node] = []

	if node != my_id:
		if payload not in expected_messages[node]:
			expected_messages[node].append(payload)
		else:
			print "Warning: message already sent to node %d."%(node)

raise ShouldContinueException
end

# Recevied a DNS message. See if it's expected.
break message.cpp:776
command

payload = @(message->payload)
my_id = @(server->id)
incoming_sock_fd = @(incomingSockfd)
neighbor_id = @((server->get_neighbor(%(incoming_sock_fd)d))->id)

print "Node %d got DNS message``%s'' from neighbor %d."%(my_id, payload, neighbor_id)

if payload in expected_messages[my_id]:
	# Remove the message from the set, now that we've received it.
	expected_messages[my_id].remove(payload)
	raise ShouldContinueException
else:
	print "Warning: unexpected message."
	raise ShouldContinueException

end
