diff -ru gdb.orig/infrun.c gdb/infrun.c
--- gdb.orig/infrun.c	2006-03-26 14:28:20.000000000 -0800
+++ gdb/infrun.c	2006-03-29 18:20:53.000000000 -0800
@@ -3741,10 +3741,33 @@
 ptid_build (int pid, long lwp, long tid)
 {
   ptid_t ptid;
+#ifdef GEELS_FIX
+  static long ghost_lwp = 0;	/* lwp of original process; now defunct. */
+#endif GEELS_FIX
 
   ptid.pid = pid;
   ptid.lwp = lwp;
   ptid.tid = tid;
+
+#ifdef GEELS_FIX  
+  printf_filtered( "ptid_build( %d, %ld, %ld )\n", pid, lwp, tid );
+    
+  /* Added by geels:
+     proc-service often finds the original process' lwp instead of the
+     restart process'.  It would be nice to know where that
+     information is stored in the checkpoint, but for now it seems
+     sufficient to simply suppress any case where the lwp contradicts
+     the pid. */
+  printf_filtered ("ghost_lwp=%d\n", ghost_lwp );
+  if( (lwp != 0) && (lwp != pid) && ((ghost_lwp == 0) || (ghost_lwp == lwp)) ) {
+    ghost_lwp = lwp;
+    ptid.lwp = pid;
+    printf_filtered ("setting lwp %d=>%d\n", lwp, pid );
+  }
+  if( (lwp != -1) && (lwp != 0) && (lwp != pid) ) {
+    printf_filtered ("ptid_build( %d %ld %ld )\n", pid, ptid.lwp, tid );
+  }
+#endif  
   return ptid;
 }
 
diff -ru gdb.orig/solib-svr4.c gdb/solib-svr4.c
--- gdb.orig/solib-svr4.c	2006-03-26 14:28:20.000000000 -0800
+++ gdb/solib-svr4.c	2006-03-25 15:51:10.000000000 -0800
@@ -618,6 +618,49 @@
 
 /*
 
+   LOCAL FUNCTION
+
+   find_r_brk
+
+   SYNOPSIS
+
+   static CORE_ADDR find_r_brk (void)
+
+   DESCRIPTION
+
+   Finds the address of a dynamic linker function (_r_debug_state).
+   See enable_break().  */
+
+static CORE_ADDR
+find_r_brk (void)
+{
+  /* This code copied (obviously) from first_link_map_member above. */
+  
+  /* FIXME: add these variables to link_map_offsets */
+#define R_BRK_SIZE	4
+#define R_BRK_OFFSET	8
+  
+  CORE_ADDR lm = 0;
+  struct link_map_offsets *lmo = SVR4_FETCH_LINK_MAP_OFFSETS ();
+  char *r_brk_buf = xmalloc (R_BRK_SIZE);
+  struct cleanup *cleanups = make_cleanup (xfree, r_brk_buf);
+
+  read_memory (debug_base + R_BRK_OFFSET, r_brk_buf, R_BRK_SIZE);
+
+  /* Assume that the address is unsigned.  */
+  lm = extract_unsigned_integer (r_brk_buf, R_BRK_SIZE);
+
+  /* FIXME:  Perhaps we should validate the info somehow, perhaps by
+     checking r_version for a known version number, or r_state for
+     RT_CONSISTENT. */
+
+  do_cleanups (cleanups);
+
+  return (lm);
+}
+
+/*
+
   LOCAL FUNCTION
 
   open_symbol_file_object
@@ -718,6 +761,7 @@
 
   /* Make sure we've looked up the inferior's dynamic linker's base
      structure.  */
+  debug_base = 0;	/* geels: Force reload  */
   if (! debug_base)
     {
       debug_base = locate_base ();
@@ -1097,6 +1141,16 @@
          closing the target closes the underlying bfd.  */
       target_close (tmp_bfd_target, 0);
 
+      if( debug_base ) {
+	/* geels: Try just reading struct r_debug.
+	   This approach is normally avoided because the field holds
+	   a relative address during startup.  However, once
+	   debug_base is valid, the linker should have updated r_brk
+	   with the correct absolute address. */
+	sym_addr = find_r_brk();
+	load_addr=0;
+      }
+      
       if (sym_addr != 0)
 	{
 	  create_solib_event_breakpoint (load_addr + sym_addr);
