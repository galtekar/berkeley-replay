#!/usr/bin/perl -w

#
# This is a simple script that verifies that logging and replay
# produce identical program output. Only stdio ouput is checked.
#
# You can specify the test programs you want verified as argument
# to this script. If you don't provide arguments, then a default
# set of test programs will be checked.
#

use strict;
use Cwd;

my(@default_test_programs) = (
	 "simple", "cplusplus",
	 "exec",
	 "fork 1", "fork 2", "fork 8", "fork 32", "fork 128", "fork 256",
	 "threads 1", "threads 2", "threads 8", "threads 32", "threads 128", "threads 256",
	 "procthreads 3 2",
	 "procthreads 2 3",
	 "procthreads 4 32",
	 "procthreads 32 4",
	 "procthreads 16 16",
	 #"procthreads 2 512",
	 #"procthreads 4 256",
	 #"procthreads 8 128",
	 #"procthreads 32 64",
	 #"procthreads 128 8",
	 "shared", "sysv", "daemon",
	 "fs", "fcntl",
	 "gethostbyname",
	 );

my($ret, $child_pid, $prog);
my($tmpdir) = "traces";
my($curdir);
my($oldout);

sub clean_ipc {
	my($user);

	$user = `whoami`;
	chomp($user);
	open(IPCS, "ipcs |") || die "can't run ipcs: $!";
	while (<IPCS>) {
		next if not /$user/o;
		split;
		my($id) = $_[1];
		system("ipcrm shm $id > /dev/null");
	}
	close(IPCS);
}

sub safe_exit {
	my($str) = @_;

	kill 2, $child_pid;
	wait();

	$curdir = getcwd;

	clean_ipc();

	die "$str\nPlease check $curdir for trace.\n"
}

sub success_exit {
	my($str) = @_;

	kill 2, $child_pid;
	wait();

	exit;
}


# Returns a sorted list of checkpoints for app with specified name and
# group id.
sub get_checkpoint_list {
	my($app_name, $grp) = @_;
	my @checkpoint_list;

	# Obtain the list of checkpoints created by the replay
	# executable.
	opendir (DIR, ".") or die "Unable to open working directory: $!\n";
	my @files = readdir(DIR);
	closedir (DIR);

	foreach my $file (@files) {
		if ($file =~ /$app_name.\d+.\d+.\d+.\d+.$grp.*ckpt.master/) {
			push (@checkpoint_list, $file);
		}
	}

	return sort @checkpoint_list;
}

# Returns a sorted list of logs for app with specified name and
# group id.
sub get_log_list {
	my($app_name, $grp) = @_;
	my @checkpoint_list;

	# Obtain the list of checkpoints created by the replay
	# executable.
	opendir (DIR, ".") or die "Unable to open working directory: $!\n";
	my @files = readdir(DIR);
	closedir (DIR);

	foreach my $file (@files) {
		if ($file =~ /$app_name.\d+.\d+.\d+.\d+.$grp.*log.gz/) {
			push (@checkpoint_list, $file);
		}
	}

	return sort @checkpoint_list;
}

sub spin_until_file_exists {
	my($file) = @_;
	do {
	} while	(not stat($file));
}

sub pid_cleanup {
	my($pid) = @_;

	kill 9, $pid;
}

# Like the system() command, but also return pid.
sub my_system {
	my($cmd) = @_;
	my($ret, $cpid);

	$ret = fork;
	if ($ret) {
		# child_pid should be the same as the child's process group id.
		$cpid = wait();
	} else {
		# We want the child to be in its own process group.
		setpgrp(0,0);
		exec $cmd or print STDERR "couldn't exec $prog: $!\n";
	}

	return $cpid;
}

sub test {
	my($cmdline) = @_;
	my(@s);
	my($grp);
	my(@cmd_list) = split (/ /, $cmdline);
	my($prog) = $cmd_list[0];
	my($timeout) = 60;


	# Get rid of temporary files from previous runs. These may
	# interfere with this run (e.g., with pid wraparound).
	$ret = system "rm -f /tmp/done.with.*";

	$ret = fork;
	if ($ret) {
		# Wait until either app processes have terminated or timeout.
		# If the app doesn't output a file with name ``done.with.log.PID''
		# within the timeout period, then its a failure.
		$grp = eval {
			my($cpid);
			my($time_remaining);
			local $SIG{ALRM} = sub { die "x" };
			alarm $timeout;

			$cpid = wait;

			spin_until_file_exists("/tmp/done.with.log.$cpid");

			$time_remaining = alarm 0;

			# We assume that $child_pid == child's group id.
			$cpid;
		};

		if ($@ and $@ =~ /x/) { print "\t[timeout]\n"; pid_cleanup($ret); return; }

		print ".";

	} else {
		# Try not to disturb any running loggers.
		$ENV{'LOGGER_PORT'} = "22819";
		$ENV{'LD_PRELOAD'} = "liblog.so";
		$ENV{'PATH'} = "$ENV{'PATH'}:../";

		# Obtain a new group id in order to distinguish this run of
		# program from past runs.
		setpgrp(0,0);
		$grp = getpgrp;

		# Suppress output from the logger by redirecting to /dev/null.
		# Output errors to a file
		open STDERR, ">logerrors.$grp" or die "Can't redirect STDERR: $!";
		open STDOUT, ">log.$grp" or die "Can't redirect STDOUT: $!";

		# Don't put any shell metacharacters in the command. If you do,
		# perl will run the command under ``sh'', and sh will be
		# logged as well, and this confuses the test script.
		$ret = exec "$cmdline" or print STDERR "coudln't exec $prog: $!";
	}

	# Wait until the logger writes the log file to disk before
	# we proceed with replay.
	spin_until_file_exists("/tmp/done.with.flush.$grp");
	print ".";

	$ret = fork;

	if ($ret) {

		# Wait until ALL app processes have terminated. This happens when
		# the app outputs a file with name ``done.with.log.PID''.
		eval {
			local $SIG{ALRM} = sub { die "x"; };
			alarm $timeout;

			wait;

			spin_until_file_exists("/tmp/done.with.replay.$grp");

			alarm 0;
		};

		if ($@ and $@ =~ /x/)
			{ print "\t[fail]\n"; pid_cleanup($ret); return; }

		print ".";
	} else {
		my(@checkpoints) = get_checkpoint_list($prog, $grp);
		my(@logs);

		if (@checkpoints == 0) {
			print "\t[can't find any checkpoints]\n"; pid_cleanup($ret); return;
		}

		# libreplay no longer uses zlib, so we must uncompress the file
		# manually.
		system "gzip -d *.gz";

		open STDERR, ">reperrors.$grp" or die "Can't redirect STDERR: $!";
		my(@args) = ("../../libckpt/ckpt_restart $checkpoints[0] >rep.$grp");
		$ret = exec (@args) or print STDERR "couldn't exec @args: $!";
	}

	$ret = system "diff log.$grp rep.$grp > /dev/null";
	if ($ret != 0) {
		print "\t[fail]\n";
		return;
	}
	print ".";

	print "\t[pass]\n";

	#$ret = system "rm -f ./$prog.$grp.*.ckpt.master ./$prog.$grp.*.log";
}

my (@prog_list) = @default_test_programs;

########################################################################
# Main
########################################################################
print "Checking if logging and replay works. This will take a few minutes.\n";
#system "rm -fr $tmpdir";
	$ret = system "mkdir $tmpdir >& /dev/null";
	$ret = chdir $tmpdir;


# Fork, and make the child process the logger process.
$child_pid = fork();

if ($child_pid) {

	# If the user specified a test to run, then run it. Otherwise, go
	# through our regression test suite.
	if (@ARGV > 0) {
		@prog_list = @ARGV;
	}

	foreach $prog (@prog_list) {
		# We sleep to give the logger process a chance to start up before
		# we blast log entries to it. We do this every iteration because
		# the logger may have dies in the previous one.
		sleep 1;

		printf "%-20s", $prog;
		test($prog);
	}

# Remove trace dir and files, now that we've made it through
# all the tests.
	chdir "../";

	success_exit();
} else {
	my(@args) = ("22819");
	my($cpid);


	#cleanipc();

	# If the logger dies, fork off another one.
	while (1) {
		$cpid = fork;
		if ($cpid) {
			$SIG{INT} = sub { kill 2, $cpid; wait; clean_ipc(); exit; };

			wait;
			clean_ipc();
		} else {
			# Suppress output from the logger by redirecting to /dev/null.
			open STDOUT, ">logger.log" or die "Can't redirect STDOUT: $!";
			open STDERR, ">logger.log" or die "Can't redirect STDERR: $!";
			exec "../../logger/loggerbin", @args or print STDERR "couldn't exec logger: $!";
		}
	}
}
