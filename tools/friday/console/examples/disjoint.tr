# Assumptions:
# ``dbreak'' sets the specified breakpoint on all nodes
# ``dwatch'' sets the specified watchpoint on all nodes
# ``watch'' sets the specified watchpoint only on the active node
# ``dbreak'' and ``dwatch'' may be nested
# Auxiliarly Python functions may be defined

#debug
#debug

#py DEBUG=True
#py DEBUG=False

py sys.path.append("/home/galtekar/src/work/logreplay/console/examples")
py from disjoint import *

replay ./good10.txt











all

#set debug_level=2

# Adjacency matrix: connectivity info of entire distributed system.
py graph = zero_matrix(10,10)

# Mapping from Friday node IDs to app-level node IDs.
py nodes = {}

# Mapping from watchpoint number to neighbor pointer
py watchpoint_aux = {}

#############################################################
# Maintaining Application to Friday Mappings
#############################################################

# We want to create a mapping from Friday node ID to IP address.
# This is how we do it with watchpoints. Note that the top-level
# breakpoint is unavoidable since we can't watch the IP address
# field until after the Server object has been created.
break config.cpp:73
command
# Create a mapping from Friday node ID to IP address.
my_addr = @(id)
print "my id: " + str(my_addr)
if my_addr != None:
	nodes[my_addr] = __NODE__
	raise ShouldContinueException
else:
	print "Host's ID is null."
end


#############################################################
# Maintaining a Connectivity Graph
#############################################################
py watch_set = set()

# Global Path Reliability Matrix. Entry (i,j) is the vclock
# time at which path i-->j was discovered by Friday to
# be reliable.
py global_PRM = zero_matrix(10, 10)

# Local Path Reliability Matrix. Entry (i,j) is the vclock
# time at which path i->j was discovered by node i to
# be reliable.
py local_PRM = zero_matrix(10, 10)

# Break at Server::init_neighbors, just right after creating each
# neighbor object. Use the opportunity to set watchpoints on
# key neighbor object state.
break server.cpp:355
command

neighbor_pointer = "(*(i->_M_node))"
neighbor_status_addr = @((long)&(%(neighbor_pointer)s->status))
neighbor_pointer_val = @(%(neighbor_pointer)s)

# It's possible that this breakpoint may fire more than
# once at the same location (usually twice) due to a bug.
# So this is a hack to ensure that there is at most 1
# watchpoint per address location per node.
if (__NODE__.index, neighbor_status_addr) in watch_set:
	raise ShouldContinueException

watch_set.add((__NODE__.index, neighbor_status_addr))

# Hack. The watch() places a watchpoint at the nodes
# in the main._current_replay_ids set.
save_ids = main._current_replay_ids
main._current_replay_ids = [__NODE__.index]

widx = watch( ["*%d"%neighbor_status_addr] )

# Associate the neighbor's pointer value with this watchpoint
# so that it is available for derefence in the watchpoint
# handler.
watchpoint_aux[widx] = neighbor_pointer_val
np = neighbor_pointer_val
#print "Saving pointer value to 0x%.2x%.2x%.2x%.2x"%(np[3], np[2], np[1], np[0])
#print "Pointer val ", neighbor_pointer_val

print "Setting watchpoint %d at 0x%x."%(widx, neighbor_status_addr)

set_command("""
main.call_gdb(__NODE__, "set language c", action="discard", may_hit_breakpoint=False)

# Update the graph when neighbor connects or disconnects.
nptr = watchpoint_aux[current_wp.index]
string_nptr = "0x%.2x%.2x%.2x%.2x"%(nptr[3], nptr[2], nptr[1], nptr[0])

#print "Stopped on watchpoint ", current_wp.index, " with ptr ", string_nptr

status = @((long)(((Neighbor*)(%(string_nptr)s))->status))
id = @((long)(((Neighbor*)(%(string_nptr)s))->id))
my_id = @((long)server->id)

print "My id is ", my_id, ", neighbor id is ", id, " with status ", status

# Update the graph if the status has changed to CONNECTED=1.
if status > 0:
	graph[my_id][id] = 1

print graph

#############################################################
# Computing Disjoint Paths
#############################################################

# Compute number of disjoint paths to al nodes from current node.
# If the number meets the minimum (k), then mark the current vclock
# time.
k = @(server->k)
disjoint_paths = []
for node in range(len(graph)):
	real_k = len(vertex_disjoint_paths(graph, my_id, node))
	
	disjoint_paths.append(real_k)

	if real_k >= k:
		global_PRM[my_id][node] = __VCLOCK__
		#print global_PRM

print "Number of disjoint paths from ", my_id, " :", disjoint_paths

raise ShouldContinueException
"""+"end")

# Hack to make things work. Should be taken out for paper.
main._current_replay_ids = save_ids
raise ShouldContinueException
end

#############################################################
# Disjoint Path Convergence Statistics
#############################################################
# DataContainer::compute_flows. Upgrading node to be reliable.
# Mark the time in the local Path Reliability Matrix.
break dc.cpp:175
command

k = @(server->k)
source = @(server->id)
sink = @(sink) - 1


app_num_disjoint_paths = @((long)flow)
real_k = len(vertex_disjoint_paths(graph, source, sink))
local_PRM[source][sink] = __VCLOCK__
delay = local_PRM[source][sink] - global_PRM[source][sink]

if source == sink:
	print "Warning: node %d computing disjoint paths to self."%(source)

print "Node %d found %d disjoint paths from %d --> %d in %d seconds."%(source, app_num_disjoint_paths, source, sink, delay/1000000)

if real_k < k:
	print "Warning: %d --> %d has %d < %d disjoint paths, but %d sees %d."%(source, sink, real_k, k, sink, app_num_disjoint_paths)

# Does this node think that all sinks reliable? 
# It should eventually...
everyone_is_reliable = True
delay_sum = 0
max_delay = 0

for asink in range(len(local_PRM[source])):
	if asink != source:
		if local_PRM[source][asink] <= 0:
			everyone_is_reliable = False
		else:
			delay = local_PRM[source][asink] - global_PRM[source][asink]
			assert(delay > 0)
			delay_sum += delay
			if delay > max_delay:
				max_delay = delay

average_delay = delay_sum / len(local_PRM[source])
		
if everyone_is_reliable:
	print "Node %d has upgraded all nodes in %d seconds (%d seconds average)."%(source, max_delay, average_delay)

raise ShouldContinueException
end

#############################################################
# Message Reliability Verification (based on disjoint paths)
#############################################################
# MessageHandler::process_dns_message.
# Got a message from an unreliable node. Verify that it is unreliable.
# If not, output a warning.
break message.cpp:858
command

source = @(message->id)
sink = @(server->id)
k = @(server->k)

print "Node %d got message from unreliable node %d."%(source, sink)

real_k = len(vertex_disjoint_paths(graph, source, sink))

if real_k >= k:
	# The source is reliable, but the sink doesn't think so.
	print "Warning: %d --> %d has %d >= %d disjoint paths, yet %d thinks it's unreliable."%(source, sink, 
		real_k, k, sink)

raise ShouldContinueException
end

# MessageHandler::process_dns_message
# Got a message from a reliable node. Verify that it is reliable.
# If not, output a warning.
break message.cpp:870
command

source = @(message->id)
sink = @(server->id)
k = @(server->k)

print "Node %d got message from reliable node %d."%(source, sink)

real_k = len(vertex_disjoint_paths(graph, source, sink))

if real_k < k:
	print "Warning: %d --> %d has %d < %d disjoint paths, yet %d thinks it's reliable."%(source, sink, 
		real_k, k, sink)

raise ShouldContinueException
end


#############################################################
# Detecting Spurious/Looping Messages
#############################################################
py sent_message_map = {}
py received_message_map = {}

# generate_fake_dns_message(), right before broadcasting DNS message
# to all neighbors.
# 
# Keeps track of messages (identified by payload), who sent them,
# and when. Friday's happens-before ordering guarantees this will
# be executed before the corresponding receive.
break server.cpp:21
command

Warning = False
payload = @((unsigned char*)zero_buf)
my_id = @(server->id)

# A message should be broadcast at most once.
if payload not in sent_message_map:
	sent_message_map[payload] = (my_id, __VCLOCK__)
	received_message_map[payload] = {}
else:
	id, vclock = sent_mesage_map[payload]
	print "Warning: node %d already sent this message at vclock %d."%(id, vclock)
	Warning = True

if not Warning:
	raise ShouldContinueException
end

# MessageHandler::receive_dns_message, recevied a DNS message.
#
# Makes sure we get at most one message from each neighbor.
# If we get more, that implies a message loop. This is not a 
# compelling use of global predicates since it doesn't 
# need to use global data and thus is just a centralized 
# version of a distributed implementation (e.g., using path-vectors).
break message.cpp:776
command

Warning = False
payload = @(message->payload)
my_id = @(server->id)
incoming_sock_fd = @(incomingSockfd)
neighbor_id = @((server->get_neighbor(%(incoming_sock_fd)d))->id)

print "Node %d got DNS message``%s'' from neighbor %d."%(my_id, payload, neighbor_id)

# Make sure the message was sent: either we didn't cover all the
# send detection breakpoints or this message came from outside 
# the system.
if payload not in sent_message_map:
	print "Warning: this message was never sent."
	Warning = True

#if payload not in received_message_map:
#	received_message_map[payload] = {}

if my_id not in received_message_map[payload]:
	received_message_map[payload][my_id] = {}

# We may get the same message multiple times, but from different
# neighbors. However, we should not get the same message more than
# once from the same neighbor--that may indicate a looping message.
if neighbor_id not in received_message_map[payload][my_id]:
	received_message_map[payload][my_id][neighbor_id] = __VCLOCK__
else:
	print "Warning: message already received from neighbor %d at time %d."%(neighbor_id, received_message_map[payload][my_id][neighbor_id])
	Warning = True

if not Warning:
	raise ShouldContinueException

end

#############################################################
# Detecting Lost Messages
#############################################################
# MessageHandler::receive_dns_message, recevied a DNS message.
#
# Makes sure that a DNS broadcast is received by
# all nodes except the sender within some time limit. If
# that doesn't happen, produce time-out warnings.
break message.cpp:776
command

Warning = False

for apayload in sent_message_map:
	source_id, send_time = sent_message_map[apayload]
	not_received_by = []

	if (__VCLOCK__ - send_time) > 20:
		for node in range(len(graph)):
			#if node != source_id and node in received_message_map[apayload] and len(received_message_map[apayload][node].keys()) == 0 and (send_time - send_time) > 20:
			if node != source_id and node not in received_message_map[apayload]:
				not_received_by.append(node)
				Warning = True

		print "``%s'' not received by"%(apayload), not_received_by

if not Warning:
	raise ShouldContinueException

end
